// logo/handler_custom.go
package logger

import (
	"context"
	"log/slog"
)

// // UseCustomHandler allows the use of a custom slog handler.
// type CustomHandler struct{}

// func (h *CustomHandler) Enabled(_ context.Context, level slog.Level) bool {
// 	return true
// }

// // Handle processes a log record and outputs it in a custom format.
// func (h *CustomHandler) Handle(_ context.Context, r slog.Record) error {
// 	fmt.Printf("[CUSTOM] %s [%s] %s\n", r.Time.Format("15:04:05"), r.Level, r.Message)
// 	return nil
// }

// // WithAttrs is a no-op for this custom handler.
// func (h *CustomHandler) WithAttrs(_ []slog.Attr) slog.Handler { return h }

// // WithGroup is a no-op for this custom handler.
// func (h *CustomHandler) WithGroup(_ string) slog.Handler { return h }

type LevelNameHandler struct {
	slog.Handler
}

// NewLevelNameHandler creates a new handler that renames the log level attribute to "level".
// It removes the original "LEVEL" attribute if present.
func NewLevelNameHandler(base slog.Handler) slog.Handler {
	return &LevelNameHandler{Handler: base}
}

func (h *LevelNameHandler) Enabled(ctx context.Context, level slog.Level) bool {
	return h.Handler.Enabled(ctx, level)
}

// Enabled checks if the handler is enabled for the given log level.
func (h *LevelNameHandler) Handle(ctx context.Context, r slog.Record) error {
	// Convert the record with proper level name for display
	levelStr := levelToString(r.Level)
	if levelStr != "" {
		r.AddAttrs(slog.String("level", levelStr))
	}
	if includeSource {
	}

	return h.Handler.Handle(ctx, r)
}

func (h *LevelNameHandler) WithAttrs(attrs []slog.Attr) slog.Handler {
	return &LevelNameHandler{Handler: h.Handler.WithAttrs(attrs)}
}

func (h *LevelNameHandler) WithGroup(name string) slog.Handler {
	return &LevelNameHandler{Handler: h.Handler.WithGroup(name)}
}

// renameLevel modifies the log record to include a "level" attribute with the log level name.
// It removes the original "LEVEL" attribute if present.
// func (h *LevelNameHandler) renameLevel(r slog.Record) slog.Record {
// 	levelName := levelToString(r.Level)
// 	if levelName == "" {
// 		return r
// 	}

// 	var newAttrs []slog.Attr
// 	r.Attrs(func(a slog.Attr) bool {
// 		if strings.ToUpper(a.Key) != "LEVEL" {
// 			newAttrs = append(newAttrs, a)
// 		}
// 		return true // continue iteration
// 	})

// 	// Inject the renamed level attr at the top
// 	newAttrs = append([]slog.Attr{slog.String("level", levelName)}, newAttrs...)

// 	// Create a new Record to apply the updated attrs
// 	newRec := slog.NewRecord(r.Time, r.Level, r.Message, r.PC)
// 	for _, attr := range newAttrs {
// 		newRec.AddAttrs(attr)
// 	}
// 	return newRec
// }

// levelToString converts a slog.Level to its string representation.
func levelToString(l slog.Level) string {
	switch l {
	case LevelTrace:
		return "TRACE"
	case slog.LevelDebug:
		return "DEBUG"
	case slog.LevelInfo:
		return "INFO"
	case slog.LevelWarn:
		return "WARN"
	case slog.LevelError:
		return "ERROR"
	case LevelFatal:
		return "FATAL"
	default:
		return ""
	}
}
